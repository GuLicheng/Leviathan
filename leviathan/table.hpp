#pragma once

#include <type_traits>
#include <array>

namespace cpp
{

// /**
//  * @brief Make a table for searching faster.
//  * 
//  * @param Config A struct or class contains follows:
//  *  - typename Config::type  value_type of table if present, otherwise int.
//  *  - Config::value          capacity of table if present, otherwise 256.
//  *  - Config::operator()     generate number sequence, the sequence is between [0, value).
//  * 
//  *  The Config::operator() accept a size_t variable as input and return a 
//  *  typename Config::type variable.
//  * 
//  * @return std::array<type, value> with value generated by Config::operator().
// */
// template <typename Config>
// constexpr auto make_character_table(Config cfg)
// {
//     using value_type = decltype([]{
//         if constexpr (requires { typename Config::type; })
//         {
//             return typename Config::type(); // We use std::array which requires T should be default_constructible
//         }
//         else
//         {
//             using T = std::invoke_result_t<Config, size_t>;
//             return T();
//         }
//     }());

//     constexpr auto count = []{
//         if constexpr (requires { Config::value; })
//         {
//             return Config::value;
//         }
//         else
//         {
//             return 256;
//         }
//     }();

//     static_assert(std::is_integral_v<value_type> || std::is_enum_v<value_type>);
//     static_assert(count <= 256);

//     using return_type = std::invoke_result_t<Config, size_t>;
//     static_assert(std::is_same_v<return_type, value_type>);
//     // TODO: This constraint maybe too strict.

//     std::array<value_type, count> table;

//     for (size_t i = 0; i < table.size(); ++i)
//     {
//         table[i] = cfg(i);
//     }

//     return table;
// }



}
