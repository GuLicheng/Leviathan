#pragma once

#include "optional.hpp"

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <cstdint>
#include <concepts>
#include <charconv>

#include <ctype.h>

namespace leviathan::config
{
    inline std::string read_file_contents(const char* filename)
    {
        std::fstream ifs(filename, std::ios_base::in | std::ios_base::binary);
        
        // Slow. https://insanecoding.blogspot.com/2011/11/how-to-read-in-file-in-c.html
        // return std::string(std::istreambuf_iterator<char>(ifs), std::istreambuf_iterator<char>()); 

        std::string contents;

        if (ifs)
        {
            ifs.seekg(0, std::ios::end);
            contents.resize(ifs.tellg());
            ifs.seekg(0, std::ios::beg);
            ifs.read(&contents[0], contents.size());
        }
        return contents;
    }
}

namespace leviathan::config
{
    template <std::integral I>
    constexpr optional<I> from_chars_to_optional(const char* startptr, const char* endptr, int base = 10)
    {
        I value;
        auto result = std::from_chars(startptr, endptr, value, base);
        if (result.ec == std::errc() && result.ptr == endptr)
            return value;
        return nullopt;
    }

    template <std::floating_point F>
    constexpr optional<F> from_chars_to_optional(const char* startptr, const char* endptr, std::chars_format fmt = std::chars_format::general)
    {
        F value;
        auto result = std::from_chars(startptr, endptr, value, fmt);
        if (result.ec == std::errc() && result.ptr == endptr)
            return value;
        return nullopt;
    }
}

namespace leviathan::config
{
    consteval bool is_utf8() 
    {
        constexpr unsigned char micro[] = "\u00B5";
        return sizeof(micro) == 3 && micro[0] == 0xC2 && micro[1] == 0xB5;
    }

    /**
     * @brief Make a table for searching faster.
     * 
     * @param Config A struct or class contains follows:
     *  - typename Config::type  value_type of table if present, otherwise int.
     *  - Config::value          capacity of table if present, otherwise 128.
     *  - Config::operator()     generate number sequence, the sequence is between [0, value).
     * 
     *  The Config::operator() accept a size_t variable as input and return a 
     *  typename Config::type variable.
     * 
     * @return std::array<type, value> with value generated by Config::operator().
    */
    template <typename Config>
    constexpr auto make_character_table(Config cfg)
    {
        using value_type = decltype([]{
            if constexpr (requires { typename Config::type; })
                return typename Config::type(); // We use std::array which requires T should be default_constructible
            else
                return int();
        }());

        constexpr auto count = []{
            if constexpr (requires { Config::value; })
                return Config::value;
            else
                return 128;
        }();

        static_assert(std::is_integral_v<value_type> && "Only support integral");
        static_assert(count <= 256);

        using return_type = std::invoke_result_t<Config, size_t>;
        static_assert(std::is_same_v<return_type, value_type>);
        // TODO: This constraint maybe too strict.

        std::array<value_type, count> table;

        for (size_t i = 0; i < table.size(); ++i)
        {
            table[i] = cfg(i);
        }

        return table;
    }

    namespace detail
    {
        struct digit_value_config
        {
            constexpr int operator()(size_t x) const
            {
                if ('0' <= x && x <= '9') return x - '0';       // [0-9]
                if ('a' <= x && x <= 'f') return x - 'a' + 10;  // [a-f]
                if ('A' <= x && x <= 'F') return x - 'A' + 10;  // [A-F]
                return -1;
            }
        };

        inline constexpr auto digit_values = make_character_table(detail::digit_value_config());
    }

    /**
     * @brief Decode unicode from C-style string. 
     * 
     * @param p The string to be decoded, please make sure that the p has at least N bytes.
     * @param N Length of p, 4 for '\u' and 8 for '\U'
    */
    template <size_t N> 
    constexpr unsigned decode_unicode_from_char(const char* p)
    {
        static_assert(N == 4 || N == 8);

        auto to_digit = [](char ch) -> unsigned
        {
            // The static variable will make this function non-constexpr.
            return detail::digit_values[ch];
            // if (ch >= '0' && ch <= '9') return ch - '0';
            // if (ch >= 'a' && ch <= 'z') return ch - 'a' + 10;
            // return ch - 'A' + 10;
        };

        unsigned i = 0;
        if constexpr (N == 4)
        {
            i |= to_digit(p[0]) << 12;
            i |= to_digit(p[1]) << 8;
            i |= to_digit(p[2]) << 4;
            i |= to_digit(p[3]);
        }
        else
        {
            i |= to_digit(p[0]) << 28;
            i |= to_digit(p[1]) << 24;
            i |= to_digit(p[2]) << 20;
            i |= to_digit(p[3]) << 16;
            i |= to_digit(p[4]) << 12;
            i |= to_digit(p[5]) << 8;
            i |= to_digit(p[6]) << 4;
            i |= to_digit(p[7]);
        }
        return i;
    }

    /**
     * @brief Check whether code is valid(each character should 
     *  be xdigit.
     * 
     * @param p Unicode sequence to be encoded, please make sure that the p has at least N bytes.
     * @param N Length of unicode, 4 for \u and 8 for \U.
    */
    template <size_t N>   
    constexpr bool is_unicode(const char* p)
    {
        static_assert(N == 4 || N == 8);

        if constexpr (N == 4)
        {
            return isxdigit(p[0])
                && isxdigit(p[1])
                && isxdigit(p[2])
                && isxdigit(p[3]);
        }
        else
        {
            return isxdigit(p[0])
                && isxdigit(p[1])
                && isxdigit(p[2])
                && isxdigit(p[3])
                && isxdigit(p[4])
                && isxdigit(p[5])
                && isxdigit(p[6])
                && isxdigit(p[7]);
        }
    }

    /**
     * @brief Encode codepoint to char-array.
     * 
     * @return Position after encoding codepoint, if the codepoint is invalid, the
     *  iter will not increase.
     * 
     * E.g.
     *   system("chcp 65001");
     *   unsigned codepoints[] = { 0x6211, 0x7231, 0x5317, 0x4eac, 0x5929, 0x5b89, 0x95e8 }; 
     *   char buffer[128] = {};
     *   char* pos = buffer;
     *   for (auto codepoint : codepoints)
     *      pos = encode_unicode_to_utf8(pos, codepoint);
     *   std::cout << buffer << " - " << std::distance(buffer, pos); // 我爱北京天安门 - 21
    */
    template <typename InputIterator>
    constexpr InputIterator encode_unicode_to_utf8(InputIterator iter, const uint32_t codepoint)
    {
        if (codepoint <= 0x0000007F)
        {
            // * U-00000000 - U-0000007F:  0xxxxxxx
            *iter++ = (codepoint & 0x7F);
        }
        else if (codepoint <= 0x000007FF)
        {
            // * U-00000080 - U-000007FF:  110xxxxx 10xxxxxx
            *iter++ = ((codepoint >> 6) & 0x1F) | 0xC0;
            *iter++ =  (codepoint & 0x3F)       | 0x80;
        }
        else if (codepoint <= 0x0000FFFF)
        {
            // * U-00000800 - U-0000FFFF:  1110xxxx 10xxxxxx 10xxxxxx
            *iter++ = ((codepoint >> 12) & 0x0F) | 0xE0;
            *iter++ = ((codepoint >> 6) & 0x3F)  | 0x80;
            *iter++ =  (codepoint & 0x3F)        | 0x80;
        }
        else if (codepoint <= 0x001FFFFF)
        {
            // * U-00010000 - U-001FFFFF:  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            *iter++ = ((codepoint >> 18) & 0x07) | 0xF0;
            *iter++ = ((codepoint >> 12) & 0x3F) | 0x80;
            *iter++ = ((codepoint >> 6) & 0x3F)  | 0x80;
            *iter++ =  (codepoint & 0x3F)        | 0x80;
        }
        else if (codepoint <= 0x03FFFFFF)
        {
            // * U-00200000 - U-03FFFFFF:  111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
            *iter++ = ((codepoint >> 24) & 0x03) | 0xF8;
            *iter++ = ((codepoint >> 18) & 0x3F) | 0x80;
            *iter++ = ((codepoint >> 12) & 0x3F) | 0x80;
            *iter++ = ((codepoint >> 6) & 0x3F)  | 0x80;
            *iter++ =  (codepoint & 0x3F)        | 0x80;
        }
        else if (codepoint <= 0x7FFFFFFF)
        {
            // * U-04000000 - U-7FFFFFFF:  1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
            *iter =   ((codepoint >> 30) & 0x01) | 0xFC;
            *iter++ = ((codepoint >> 24) & 0x3F) | 0x80;
            *iter++ = ((codepoint >> 18) & 0x3F) | 0x80;
            *iter++ = ((codepoint >> 12) & 0x3F) | 0x80;
            *iter++ = ((codepoint >> 6)  & 0x3F) | 0x80;
            *iter++ =  (codepoint & 0x3F)        | 0x80;
        }
        return iter;
    }
}

namespace leviathan::config
{
    template <typename T>
    concept arithmetic = std::is_arithmetic_v<T>;

    template <typename T>
    concept string_viewable = std::is_convertible_v<const T&, std::string_view>;

    template <typename T>
    concept string_view_like = string_viewable<T> && !std::is_convertible_v<const T&, const char*>;

    struct string_hash_key_equal
    {
        using is_transparent = void;

        template <string_viewable Lhs, string_viewable Rhs>
        constexpr bool operator()(const Lhs& l, const Rhs& r) const
        {
            std::string_view sl = static_cast<std::string_view>(l);
            std::string_view sr = static_cast<std::string_view>(r);
            return compare_impl(sl, sr);
        }

        template <string_viewable Str>
        constexpr bool operator()(const Str& s) const
        {
            std::string_view sv = static_cast<std::string_view>(s);
            return hash_impl(sv);
        }

    private:

        constexpr static bool compare_impl(std::string_view lhs, std::string_view rhs)
        { return lhs == rhs; }  

        constexpr static size_t hash_impl(std::string_view sv)
        { return std::hash<std::string_view>()(sv); }
    };
 
    inline constexpr const char* whitespace_delimiters = " \t\n\r";

    constexpr std::string_view ltrim(std::string_view sv, std::string_view delimiters = whitespace_delimiters)
    {
        auto left = sv.find_first_not_of(delimiters);
        return sv.substr(left == sv.npos ? sv.size() : left);
    }

    constexpr std::string_view rtrim(std::string_view sv, std::string_view delimiters = whitespace_delimiters)
    {
        auto right = sv.find_last_not_of(delimiters);
        return sv.substr(0, right + 1);
    }

    constexpr std::string_view trim(std::string_view sv, std::string_view delimiters = whitespace_delimiters)
    { return rtrim(ltrim(sv, delimiters), delimiters); }

    std::string_view trim(const std::string& s, std::string_view delimiters = whitespace_delimiters)
    {
        std::string_view sv = s;
        return trim(sv, delimiters);        
    }

    inline std::string replace(std::string str, std::string_view from, std::string_view to)
    {
        size_t pos = 0;
        while ((pos = str.find(from, pos)) != str.npos)
        {
            str.replace(pos, from.size(), to);
            pos += to.size();
        }
        return str;
    }
}
